{
    "java知识": {
        "概念":{

        },
        "jvm":{

        },
        "基础": {
            "关键字":{
                "final":[
                    "final修饰的变量不能被修改",
                    "final修饰的变量必须初始化"
                ],
                "static":[
                    "static修饰的变量属于类，不属于对象",
                    "static修饰的变量属于类，不属于对象，所以static修饰的变量可以不初始化"
                ],
                "abstract":[
                    "抽象类不能被实例化",
                    "抽象类可以包含抽象方法"
                ]
            }
        },
        "多线程":{
            "概念":{
                "可重入锁":[
                    "允许在同一个线程中多次获取同一把锁，而不会导致死锁。可重入锁的设计目的是为了防止死锁的发生",
                    "线程在获取锁之后，可以在锁的范围内再次调用锁定的代码或方法，而不会阻塞自己"
                ],
                "读写锁":[
                    "允许多个读操作并发，但写操作是独占的."
                ],
                "自旋锁":[
                    "当锁被占用时，其他线程会持续检查锁是否可用"
                ],
                "公平锁":[
                    "按照线程请求锁的顺序来分配锁，先请求的线程先获得锁，可以避免某些线程一直饿死。"
                ],
                "非公平锁":[
                    "不保证线程获取锁的顺序，性能通常优于公平锁，因为减少了锁的获取延迟。"
                ]

            },
            "锁，同步工具类":{
                "synchronized":[
                    "目的：保证同一时刻只有一个线程可以执行该代码块，原子性，可见性，有序性",
                    "用法：修饰方法，代码块",
                    "特点：可重入锁。锁的对象可以是实例对象，class类。不需要手动释放锁。"
            
                ],
                "volatile":[
                    "目的：可见性：当一个线程修改了volatile变量的值，新值对所有其他线程都是立即可见的。这是因为volatile变量的读写操作不会被编译器或处理器重排序，而且写操作会强制将修改的值写回到主内存中，读操作会从主内存中读取最新的值。这种行为确保了即使在多线程环境下，对volatile变量的修改也能被其他线程及时感知。",
                    "用法：声明变量"
                ],
                "ReentrantLock":[
                    "特点：可重入锁，需要手动释放锁,公平锁，非公平锁，可尝试获取锁",
                    "本质 是内部实现了AQS类"

                ],
                "CountDownLatch":[
                    "本质 是内部实现了AQS类",
                    "所有子线程都释放锁后，CountDownLatch才会继续执行"

                ],
                "CyclicBarrier":[
                    "本质 使用ReentrantLock",
                    "可重复使用",
                    "所有子线程都达到屏障点后，才会继续执行"
                ],
                "Semaphore":[],
                "Condition":[
                    "平替Object中的wait和notify方法"
                ],
                "AbstractQueuedSynchronizer":[]
            },
            "线程以及管理":{
                "Thread":[

                ],
                "线程生命周期":[
                    "getState()方法",
                    "NEW：线程对象创建但是没有启动",
                    "RUNNABLE：线程可以被其他线程调用start方法启动，执行start()后",
                    "BLOCKED：线程正在等待监视器锁，以便进入synchronized块或方法",
                    "WAITING：当前线程等待别的线程 Object.wait ，Thread.join",
                    "TIMED_WAITING：线程执行完毕或者被终止，Thread.sleep，Object.wait ，Thread.join",
                    "TERMINATED: 线程执行完毕或者被终止"

                ],
                "线程池":[],
                "线程工具":[]
            }
        },
        "集合": {
            "List": {
                "ArrayList": [
                    "动态数组",
                    "线程不安全",
                    "扩容机制：没有指定初始容量，它默认容量是 10,默认的扩容策略是新容量为当前容量的1.5倍"
                ],
                "LinkedList": [
                    "双向链表",
                    "线程不安全",
                    "扩容机制：无",
                    "LinkedList在插入和删除操作上通常比ArrayList快，因为不需要移动元素,但是，随机访问元素时，LinkedList需要从头或尾部遍历链表这会导致O(n)的时间复杂度，而ArrayList的随机访问时间复杂度为O(1)"
                ],
                "CopyOnWriteArrayList": [
                    "动态数组",
                    "线程安全",
                    "扩容机制：",
                    "CopyOnWriteArrayList是线程安全的，但是，它的性能却比ArrayList差，因为每次写入都需要复制一份数组，所以，如果写入操作的次数远多于读取操作的次数，那么CopyOnWriteArrayList性能就非常差。",
                    "适合多读少写场景",
                    "todo null",
                    "CopyOnWriteArrayList的迭代器提供了一个快照视图，在迭代过程中集合的修改不会反映在迭代器上。迭代器不会抛出ConcurrentModificationException，但返回的数据可能不是最新的。",
                    "写操作过程：1️⃣获取ReentrantLock锁，确保写操作的排他性，防止其他写操作同时进行。2️⃣创建当前base数组的副本。3️⃣在副本上执行所需的写操作。4️⃣更新base数组的引用，使其指向新的副本。5️⃣释放锁。"
                ],
                "Vector":[
                    "动态数组",
                    "线程安全,synchronized修饰方法",
                    "扩容机制：默认容量是 10, 当Vector的元素数量达到当前容量时，Vector会自动扩容。默认情况下，Vector的扩容策略是将当前容量增加一倍",
                    "适合多读少写场景"    

                ]
            },
            "Set": {
                "HashSet": [
                    "底层使用HashMap存储数据",
                    "线程不安全",
                    "允许null",
                    ""
                ],
                "TreeSet": [
                    "底层使用TreeMap存储数据",
                    "线程不安全",
                    ""
                ],
                "LinkedHashSet":[
                    "底层使用LinkedHashMap存储数据",
                    "线程不安全",
                    ""
                ]
            },
            "Map":{
                "HashMap":[
                    "底层使用Node数组,存储数据,数据元素Node 又细分为Node数组，TreeNode, ",
                    "线程不安全",
                    "允许一个null键,允许多个null值",
                    "扩容机制：当HashMap中的元素数量达到容量乘以负载因子时，会触发扩容操作",
                    "插入数据步骤：1️⃣如果哈希表为空，则进行初始化。2️⃣根据哈希值和哈希表长度计算出插入位置。3️⃣如果插入位置为空，则创建新节点并插入。4️⃣如果插入位置已有节点：1.如果节点的键与插入键等，则更新节点的值并返回旧值。2.如果节点是TreeNode（表示是一个红黑树节点），则调用putTreeVal方法进行树中插入操作。3否则，遍历链表，找到第一个哈希值和键相等的节点，进行相同操作,并链表转换为TreeNode。" ,
                    "删除数据步骤："

                ],
                "TreeMap":[
                    "红黑树",
                    "线程不安全",
                    "可以自定义 键的排序顺序",
                    "适用于需要排序或查找特定范围的键值对的场景"
                ],
                "LinkedHashMap":[
                    "继承 HashMap",
                    "线程不安全",
                    "适用于需要保持元素插入或访问顺序的场景，同时保持高效查找性能。"
                ]
            },
            "Stack":{
                "ArrayStack":[],
                "LinkedStack":[]
            },
            "Queue":{
                "ArrayQueue":[],
                "LinkedQueue":[]
            }
        }
    }
}