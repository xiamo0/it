{
    "common programing concepts": {
        "debug": {
            "struct": [
                "在 struct 上 声明 #[derive(Debug)]",
                " dbg!(&rect1);",
                " println!(\"rect1 is {rect1:#?}\");"
            ]
        },
        "variables": {
            "immutable var": [
                "声明的变量默认是 不可变的",
                "let x=5"
            ],
            "mutable var": [
                "声明 变量是 可变的",
                "let mut x=5"
            ],
            "Constants": [
                "常量 是不可变的",
                "const x=5",
                "命名常识：变量名大写下划线"
            ],
            "shadowing": [
                "仅限于 immutable 变量",
                "let x = 1;let x = x+1;",
                "shadowing 可以改变变量的 数据类型，而 mut 不可以改变变量的 数据类型"
            ]
        },
        "data types": {
            "Scalar Types": [
                "int,floating-points,character,bool"
            ],
            "Compound Types": [
                "tuple,array"
            ]
        },
        "functions": {
            "Statements": [
                "语句是执行某些操作且不返回值的指令。",
                "声明变量 是语句",
                "声明函数 是语句"
            ],
            "Expressions": [
                "rust 是基于表达式的语言",
                "表达式语句 不能有封号结尾",
                "表达式求值为结果值"
            ]
        },
        "controll flows": {},
        "keywords": {},
        "ownership": {
            "是什么": [
                "ownership是一套管理Rust程序如何管理内存的规则。所有程序都必须管理它们在运行时使用计算机内存的方式。内存通过所有权系统进行管理，并带有编译器检查的一组规则。如果违反了任何规则，程序将不会编译。所有权的任何功能都不会在程序运行时减慢速度。"
            ],
            "规则": [
                "Rust中的每个值都有一个所有者。",
                "一次只能有一个主人。",
                "当所有者超出范围时，值将被丢弃。"
            ],
            "作用": [
                "管理堆数据",
                "保证了rust内存安全",
                "使得rust不需要垃圾回收器"
            ],
            "references": [
                "在任何给定时间，一个变量可以有一个可变引用或多个不可变引用。",
                "必须始终有效"
            ],
            "slice type": {}
        },
        "struct": {
            "common struct": {
                "example": [
                    "struct User{",
                    "    username:String,",
                    "    email:String,",
                    "    sign_in_count:u64,",
                    "    active:bool,",
                    "}",
                    "impl User{",
                    "    fn new(email:String,username:String)->User{",
                    "        User{",
                    "            email:email,",
                    "            username:username,",
                    "            active:true,",
                    "            sign_in_count:1,",
                    "        }",
                    "    }",
                    "}"
                ],
                "how store references in structs": {}
            },
            "tuple struct": {
                "example": [
                    "struct Color(i32,i32,i32);"
                ]
            },
            "unit struct": {
                "example": [
                    "struct Unit;"
                ]
            },
            "methods": {
                "Associated Functions": {
                    "notes": [
                        "感觉类似java 的类方法"
                    ]
                }
            }
        },
        "Enum": {
            "Option": {
                "notes": [
                    "Rust自带的枚举",
                    "Option 是Rust 规避Null exception 的 手段"
                ]
            },
            "match control flow": {
                "notes": [
                    "if else 可以平替 match，但是match 可以匹配任何类型"
                ]
            }
        },
        "manage Rust project": {
            "Package": {
                "notes": [
                    "A Cargo feature that lets you build, test, and share crates",
                    "A package is a bundle of one or more crates ",
                    "A package contains a Cargo.toml file that describes how to build those crates",
                    "A package can contain as many binary crates as you like, but at most only one library crate.",
                    "A package must contain at least one crate, whether that’s a library or binary crate.",
                    "A package can have multiple binary crates by placing files in the src/bin directory: each file will be a separate binary crate.",
                    "create package: cargo new my-project",
                    "Cargo passes the crate root files to rustc to build the library or binary.",
                    "Cargo follows a convention that src/main.rs is the crate root of a binary crate with the same name as the package",
                    "Cargo follows a convention that src/lib.rs is the crate root of a library crate with the same name as the package"
                ],
                "Crate": {
                    "notes": [
                        "A tree of modules that produces a library or executable",
                        "A crate is the smallest amount of code that the Rust compiler considers at a time.",
                        "Binary crates: must have a function called main that defines what happens when the executable runs",
                        "Library crates: don’t have a main function, and they don’t compile to an executable. Instead, they define functionality intended to be shared with multiple projects"
                    ],
                    "modules": {}
                }
            }
        }
    }
}