{
    "common programing concepts": {
        "debug": {
            "struct": [
                "在 struct 上 声明 #[derive(Debug)]",
                " dbg!(&rect1);",
                " println!(\"rect1 is {rect1:#?}\");"
            ]
        },
        "macro ":{
            "panic!":{
                "notes": [
                    "panic! 宏会立即停止当前线程的执行并打印错误信息"
                ]
                   
            }

        },
        "operator": {
            "? operator": {
                "notes": [
                    "? 运算符的主要功能是在函数内部将一个 Result 或 Option 类型的值从一个表达式传播到函数的返回值中。当在一个函数内部遇到 ? 运算符时，如果该表达式的结果是一个 Err 或 None，那么整个函数会立即返回该结果。",
                    "在函数体内，你可以使用 ? 运算符来调用可能返回 Result 或 Option 的方法或函数。"
                ]
            }
        },
        "variables": {
            "immutable var": [
                "声明的变量默认是 不可变的",
                "let x=5"
            ],
            "mutable var": [
                "声明 变量是 可变的",
                "let mut x=5"
            ],
            "Constants": [
                "常量 是不可变的",
                "const x=5",
                "命名常识：变量名大写下划线"
            ],
            "shadowing": [
                "仅限于 immutable 变量",
                "let x = 1;let x = x+1;",
                "shadowing 可以改变变量的 数据类型，而 mut 不可以改变变量的 数据类型"
            ]
        },
        "data types": {
            "Scalar Types": [
                "int,floating-points,character,bool"
            ],
            "Compound Types": [
                "tuple,array"
            ]
        },
        "functions": {
            "Statements": [
                "语句是执行某些操作且不返回值的指令。",
                "声明变量 是语句",
                "声明函数 是语句"
            ],
            "Expressions": [
                "rust 是基于表达式的语言",
                "表达式语句 不能有封号结尾",
                "表达式求值为结果值"
            ]
        },
        "controll flows": {},
        "keywords": {},
        "ownership": {
            "是什么": [
                "ownership是一套管理Rust程序如何管理内存的规则。所有程序都必须管理它们在运行时使用计算机内存的方式。内存通过所有权系统进行管理，并带有编译器检查的一组规则。如果违反了任何规则，程序将不会编译。所有权的任何功能都不会在程序运行时减慢速度。"
            ],
            "规则": [
                "Rust中的每个值都有一个所有者。",
                "一次只能有一个主人。",
                "当所有者超出范围时，值将被丢弃。"
            ],
            "作用": [
                "管理堆数据",
                "保证了rust内存安全",
                "使得rust不需要垃圾回收器"
            ],
            "references": [
                "在任何给定时间，一个变量可以有一个可变引用或多个不可变引用。",
                "必须始终有效"
            ],
            "slice type": {}
        },
        "struct": {
            "common struct": {
                "example": [
                    "struct User{",
                    "    username:String,",
                    "    email:String,",
                    "    sign_in_count:u64,",
                    "    active:bool,",
                    "}",
                    "impl User{",
                    "    fn new(email:String,username:String)->User{",
                    "        User{",
                    "            email:email,",
                    "            username:username,",
                    "            active:true,",
                    "            sign_in_count:1,",
                    "        }",
                    "    }",
                    "}"
                ],
                "how store references in structs": {}
            },
            "tuple struct": {
                "example": [
                    "struct Color(i32,i32,i32);"
                ]
            },
            "unit struct": {
                "example": [
                    "struct Unit;"
                ]
            },
            "methods": {
                "Associated Functions": {
                    "notes": [
                        "感觉类似java 的类方法"
                    ]
                }
            }
        },
        "Enum": {
            "Option": {
                "notes": [
                    "Rust自带的枚举",
                    "Option 是Rust 规避Null exception 的 手段"
                ]
            },
            "match control flow": {
                "notes": [
                    "if else 可以平替 match，但是match 可以匹配任何类型"
                ]
            }
        },
        "manage Rust project": {
            "Package": {
                "notes": [
                    "A Cargo feature that lets you build, test, and share crates",
                    "A package is a bundle of one or more crates ",
                    "A package contains a Cargo.toml file that describes how to build those crates",
                    "A package can contain as many binary crates as you like, but at most only one library crate.",
                    "A package must contain at least one crate, whether that’s a library or binary crate.",
                    "A package can have multiple binary crates by placing files in the src/bin directory: each file will be a separate binary crate.",
                    "create package: cargo new my-project",
                    "Cargo passes the crate root files to rustc to build the library or binary.",
                    "Cargo follows a convention that src/main.rs is the crate root of a binary crate with the same name as the package",
                    "Cargo follows a convention that src/lib.rs is the crate root of a library crate with the same name as the package,example: cargo new restaurant --lib "
                ],
                "Crate": {
                    "notes": [
                        "A tree of modules that produces a library or executable",
                        "A crate is the smallest amount of code that the Rust compiler considers at a time.",
                        "Binary crates: must have a function called main that defines what happens when the executable runs",
                        "Library crates: don’t have a main function, and they don’t compile to an executable. Instead, they define functionality intended to be shared with multiple projects.  "
                    ],
                    "modules": {
                        "notes": [
                            "code within a module is private by default",
                            "pub mod",
                            "pub struct",
                            "pub field",
                            "pub fn",
                            "pub enum",
                            "pub use: called re-exporting ，因为我们将一个项目纳入范围，但也使该项目可供其他人纳入其范围。",
                            "mod 关键字：1️⃣声明 module。2️⃣引用module"
                        ]
                    }
                }
            }
        },
        "Collection": {
            "vector": {
                "notes": [
                    " let v: Vec<i32> = Vec::new();"
                ]
            },
            "String": {
                "notes": [
                    "utf-8 encode",
                    "String::from and to_string do the same thing",
                    "String is a growable,mutable,owned utf-8 encoded string type store int heap.String 包含三个部分：指向数据的指针、长度和容量 ;let s=String::from(\"hello\");",
                    "str 是一个 immutable utf-8 字符串切片，str 实际上是由一个指针和一个长度组成的元组;let s = \"hello\";"
                ]
            },
            "HashMap": {}
        },
        "Error Handing": {
            "notes": [
                "Rust groups errors into two major categories: recoverable and unrecoverable errors.",
                "Most languages don’t distinguish between these two kinds of errors and handle both in the same way, using mechanisms such as exceptions. Rust doesn’t have exceptions."
            ],
            "recoverable error": {
                "notes": [
                    "returning Result is a good default choice when you’re defining a function that might fail.",
                    "The Result enum uses Rust’s type system to indicate that operations might fail in a way that your code could recover from. You can use Result to tell code that calls your code that it needs to handle potential success or failure as well."
                ]
            },
            "unrecoverable error": {
                "notes": [
                    "The panic! macro signals that your program is in a state it can’t handle and lets you tell the process to stop instead of trying to proceed with invalid or incorrect values",
                    "手动触发： panic!(\"crash and burn\");",
                    "when program running it occurs : arr[100]",
                    "unrecoverable error 发生后，程序自动退出",
                    "In situations such as examples, prototype code, and tests, it’s more appropriate to write code that panics instead of returning a Result"
                ]
            }
        }
    }
}